const db = require('../config/database');

// Funci√≥n para obtener la fecha actual local (sin hora)
const getLocalDate = () => {
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, '0');
  const day = String(now.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
};

// Funci√≥n para obtener a√±o-mes actual local
const getLocalYearMonth = () => {
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, '0');
  return `${year}-${month}`;
};

// Generar array de fechas entre dos fechas
const generateDateRange = (startDate, endDate) => {
  const dates = [];
  const [startYear, startMonth, startDay] = startDate.split('-').map(Number);
  const [endYear, endMonth, endDay] = endDate.split('-').map(Number);

  let year = startYear;
  let month = startMonth;
  let day = startDay;

  while (true) {
    const currentDate = `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
    dates.push(currentDate);

    if (year === endYear && month === endMonth && day === endDay) break;

    day++;
    const daysInMonth = new Date(year, month, 0).getDate();
    if (day > daysInMonth) {
      day = 1;
      month++;
      if (month > 12) {
        month = 1;
        year++;
      }
    }
  }

  return dates;
};

const getDashboardStats = (req, res) => {
  try {
    const fechaHoy = getLocalDate();
    const mesActual = getLocalYearMonth();

    console.log('üìÖ Fecha hoy:', fechaHoy);
    console.log('üìÖ Mes actual:', mesActual);

    // Total de productos
    const totalProducts = db.prepare('SELECT COUNT(*) as count FROM productos WHERE activo = 1').get().count;

    // Total de clientes activos
    const totalClients = db.prepare('SELECT COUNT(*) as count FROM clientes WHERE activo = 1').get().count;

    // ‚úÖ VENTAS DE HOY - Solo dinero pagado
    const salesToday = db.prepare(`
      SELECT COUNT(*) as count, COALESCE(SUM(monto_pagado), 0) as total
      FROM ventas
      WHERE DATE(fecha) = ?
    `).get(fechaHoy);

    // ‚úÖ VENTAS DEL MES - Solo dinero pagado
    const salesMonth = db.prepare(`
      SELECT COUNT(*) as count, COALESCE(SUM(monto_pagado), 0) as total
      FROM ventas
      WHERE strftime('%Y-%m', fecha) = ?
    `).get(mesActual);

    // Productos con bajo stock (menos de 10 unidades) - SOLO ACTIVOS
    const lowStock = db.prepare(`
      SELECT id, nombre, tipo, presentacion, stock
      FROM productos
      WHERE stock < 10 AND activo = 1
      ORDER BY stock ASC
      LIMIT 5
    `).all();

    // Ventas recientes (√∫ltimas 5)
    const recentSales = db.prepare(`
      SELECT 
        v.id,
        v.fecha,
        v.total,
        v.metodo_pago,
        c.nombre as cliente_nombre
      FROM ventas v
      LEFT JOIN clientes c ON v.cliente_id = c.id
      ORDER BY v.fecha DESC
      LIMIT 5
    `).all();

    console.log('‚úÖ Stats calculados correctamente');
    console.log('üìä Ventas hoy:', salesToday);
    console.log('üìä Ventas mes:', salesMonth);

    res.json({
      totalProducts,
      totalClients,
      salesToday: {
        count: salesToday.count,
        total: salesToday.total
      },
      salesMonth: {
        count: salesMonth.count,
        total: salesMonth.total
      },
      lowStock,
      recentSales
    });

  } catch (error) {
    console.error('‚ùå Error en getDashboardStats:', error);
    res.status(500).json({ error: error.message });
  }
};

const getChartData = (req, res) => {
  try {
    const fechaHoy = getLocalDate();
    const fechaInicio = new Date();
    fechaInicio.setDate(fechaInicio.getDate() - 29);
    const fechaInicioStr = fechaInicio.toISOString().split('T')[0];

    console.log('üìä Generando charts desde:', fechaInicioStr, 'hasta:', fechaHoy);

    // ‚úÖ VENTAS POR D√çA - Solo dinero pagado
    const salesData = db.prepare(`
      SELECT DATE(fecha) as fecha,
             COUNT(*) as cantidad,
             SUM(monto_pagado) as total
      FROM ventas
      WHERE DATE(fecha) BETWEEN ? AND ?
      GROUP BY DATE(fecha)
      ORDER BY DATE(fecha)
    `).all(fechaInicioStr, fechaHoy);

    const allDates = generateDateRange(fechaInicioStr, fechaHoy);

    const salesByDay = allDates.map(date => {
      const found = salesData.find(s => s.fecha === date);
      return {
        fecha: new Date(date + 'T00:00:00').toLocaleDateString('es-CO', {
          month: 'short',
          day: 'numeric'
        }),
        ventas: found ? found.cantidad : 0,
        ingresos: found ? found.total : 0
      };
    });

    // Top productos m√°s vendidos
    const topProducts = db.prepare(`
      SELECT 
        p.nombre,
        p.tipo,
        p.presentacion,
        SUM(vd.cantidad) as cantidad_vendida,
        SUM(vd.subtotal) as total_vendido
      FROM ventas_detalles vd
      INNER JOIN productos p ON vd.producto_id = p.id
      GROUP BY vd.producto_id
      ORDER BY cantidad_vendida DESC
      LIMIT 5
    `).all();

    console.log('‚úÖ Charts generados correctamente');

    res.json({
      salesByDay,
      topProducts
    });

  } catch (error) {
    console.error('‚ùå Error en getChartData:', error);
    res.status(500).json({ error: error.message });
  }
};

const getReports = (req, res) => {
  try {
    const { fecha_inicio, fecha_fin, tipo } = req.query;

    console.log('üìä Generando reporte:', { fecha_inicio, fecha_fin, tipo });

    if (!fecha_inicio || !fecha_fin) {
      return res.status(400).json({
        DATE(v.fecha) as fecha,
        COUNT(DISTINCT v.id) as num_ventas,
        SUM(vd.subtotal) as ingresos,
        SUM(vd.cantidad * p.precio_costo) as costos,
        SUM(vd.subtotal - (vd.cantidad * p.precio_costo)) as ganancia
        FROM ventas v
        INNER JOIN ventas_detalles vd ON v.id = vd.venta_id
        INNER JOIN productos p ON vd.producto_id = p.id
        WHERE DATE(v.fecha) BETWEEN ? AND ?
        GROUP BY DATE(v.fecha)
        ORDER BY DATE(v.fecha)
        `).all(fecha_inicio, fecha_fin);

      const totalVentas = profitData.reduce((sum, day) => sum + day.num_ventas, 0);
      const totalIngresos = profitData.reduce((sum, day) => sum + (day.ingresos || 0), 0);
      const totalCostos = profitData.reduce((sum, day) => sum + (day.costos || 0), 0);
      const totalGanancias = profitData.reduce((sum, day) => sum + (day.ganancia || 0), 0);

      console.log('‚úÖ Reporte de ganancias generado:', { totalGanancias });

      res.json({
        tipo: 'ganancias',
        fecha_inicio,
        fecha_fin,
        totalVentas,
        totalIngresos,
        totalCostos,
        totalGanancias,
        data: profitData.map(day => ({
          fecha: day.fecha,
          num_ventas: day.num_ventas,
          total_ventas: day.ingresos || 0,
          ganancia_total: day.ganancia || 0,
          ingresos: day.ingresos || 0,
          costos: day.costos || 0,
          ganancia: day.ganancia || 0
        }))
      });

    } else {
      res.status(400).json({ error: 'Tipo de reporte inv√°lido. Use "ventas" o "ganancias"' });
    }

  } catch (error) {
    console.error('‚ùå Error en getReports:', error);
    res.status(500).json({ error: error.message });
  }
};

const getTopProductsByDateRange = (req, res) => {
  try {
    const { fecha_inicio, fecha_fin } = req.query;

    if (!fecha_inicio || !fecha_fin) {
      return res.status(400).json({
        error: 'Se requieren fecha_inicio y fecha_fin'
      });
    }

    // ‚úÖ Obtener TODOS los productos con sus ventas (incluyendo los que tienen 0 ventas)
    const allProducts = db.prepare(`
      SELECT
      p.id,
        p.nombre,
        p.tipo,
        p.presentacion,
        p.precio_costo,
        COALESCE(SUM(vd.cantidad), 0) as total_vendido,
        COALESCE(SUM(vd.subtotal), 0) as total_ingresos,
        COALESCE(SUM(vd.subtotal - (vd.cantidad * p.precio_costo)), 0) as ganancia_total
      FROM productos p
      LEFT JOIN ventas_detalles vd ON vd.producto_id = p.id
      LEFT JOIN ventas v ON vd.venta_id = v.id AND DATE(v.fecha) BETWEEN ? AND ?
        WHERE p.activo = 1
      GROUP BY p.id
      ORDER BY total_vendido DESC
    `).all(fecha_inicio, fecha_fin);

    res.json(allProducts);

  } catch (error) {
    console.error('‚ùå Error en getTopProductsByDateRange:', error);
    res.status(500).json({ error: error.message });
  }
};

const getSalesByTypeThisMonth = (req, res) => {
  try {
    const getLocalYearMonth = () => {
      const now = new Date();
      const year = now.getFullYear();
      const month = String(now.getMonth() + 1).padStart(2, '0');
      return `${ year } -${ month } `;
    };
    const mesActual = getLocalYearMonth();
    const salesByType = db.prepare(`
      SELECT
      p.tipo,
        SUM(vd.cantidad) as cantidad_vendida
      FROM ventas v
      INNER JOIN ventas_detalles vd ON v.id = vd.venta_id
      INNER JOIN productos p ON vd.producto_id = p.id
      WHERE p.activo = 1
        AND strftime('%Y-%m', v.fecha) = ?
        GROUP BY p.tipo
      ORDER BY cantidad_vendida DESC
        `).all(mesActual);
    res.json({ salesByType });
  } catch (error) {
    console.error('‚ùå Error en getSalesByTypeThisMonth:', error);
    res.status(500).json({ error: error.message });
  }
};

module.exports = {
  getDashboardStats,
  getChartData,
  getReports,
  getTopProductsByDateRange,
  getSalesByTypeThisMonth
};
